<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>The EquationOfState Trait &#8212; feos 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          feos</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../api/index.html">Python API</a></li>
                <li><a href="../../examples/index.html">Python Examples</a></li>
                <li><a href="../index.html">Rust Guide</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"></ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">The <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> Trait</a><ul>
<li><a class="reference internal" href="#the-helmholtzenergydual-and-helmholtzenergy-traits">The <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> and <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergy</span></code> Traits</a></li>
<li><a class="reference internal" href="#residual-helmholtz-energy">Residual Helmholtz Energy</a></li>
<li><a class="reference internal" href="#the-ideal-gas-contribution">The Ideal Gas Contribution</a></li>
<li><a class="reference internal" href="#additional-traits">Additional Traits</a><ul>
<li><a class="reference internal" href="#the-molarweight-trait">The <code class="docutils literal notranslate"><span class="pre">MolarWeight</span></code> Trait</a></li>
<li><a class="reference internal" href="#the-entropyscaling-trait">The <code class="docutils literal notranslate"><span class="pre">EntropyScaling</span></code> Trait</a></li>
</ul>
</li>
<li><a class="reference internal" href="#summary">Summary</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
              
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <section id="the-equationofstate-trait">
<h1>The <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> Trait<a class="headerlink" href="#the-equationofstate-trait" title="Permalink to this headline">¶</a></h1>
<p>In <code class="docutils literal notranslate"><span class="pre">FeOs</span></code>, an instance of an equation of state stores information of the chemical system (i.e. the model parameters) we are interested in.
But we formally make no assumptions about these model parameters - this is entirely up to the respective implementation which gives a lot of flexibility with respect to parameter handling and storage.</p>
<p>For example, we want to compute properties for a mixture containing water and acetone, so we create or read in the appropriate parameters and initialize an equation of state.
If we decide to work with different substances, we start over from scratch: somehow get parameters for the new mixture and create a <em>new</em> instance of the equation of state.
You can have multiple instances at the same time, and each can have their own parameters.</p>
<p>This concept is important, since the equation of state object, or more precisely a pointer to it, is shared between all thermodynamic states that we create with it.</p>
<p>The entry point for learning to understand how equations of state are implemented in <code class="docutils literal notranslate"><span class="pre">FeOs</span></code> is the <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> trait.
Shown below are the functions you have to implement when creating a new equation of state.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: feos-core/src/equation_of_state.rs</span>

<span class="sd">/// A general equation of state.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EquationOfState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// Return the number of components of the equation of state.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">components</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">usize</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Return an equation of state consisting of the components</span>
<span class="w">    </span><span class="sd">/// contained in component_list.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">get_subset</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">component_list</span>: <span class="kp">&amp;</span><span class="p">[</span><span class="kt">usize</span><span class="p">])</span><span class="w"> </span>-&gt; <span class="nc">Self</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Return the maximum density in Angstrom^-3.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// This value is used as an estimate for a liquid phase for phase</span>
<span class="w">    </span><span class="sd">/// equilibria and other iterations. It is not explicitly meant to</span>
<span class="w">    </span><span class="sd">/// be a mathematical limit for the density (if those exist in the</span>
<span class="w">    </span><span class="sd">/// equation of state anyways).</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">compute_max_density</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">moles</span>: <span class="kp">&amp;</span><span class="nc">Array1</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kt">f64</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Return a slice of the individual contributions (excluding the ideal gas)</span>
<span class="w">    </span><span class="sd">/// of the equation of state.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">residual</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">HelmholtzEnergy</span><span class="o">&gt;</span><span class="p">];</span><span class="w"></span>

<span class="w">    </span><span class="c1">// Other methods omitted.</span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Let’s take a look at the different methods we need to implement to qualify for an equation of state.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">components</span></code>: return the number of substances in the system you want to explore. This method is important for algorithms that are specifically written for pure component systems where the return value of <code class="docutils literal notranslate"><span class="pre">components</span></code> is used to decide what method to use.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">get_subset</span></code>: create a new equation of state for a subset of components, where the <code class="docutils literal notranslate"><span class="pre">component_list</span></code> contains the indices of the components to pick. This method allows calculating pure substance properties in a mixture in a convenient fashion.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">compute_max_density</span></code>: the returned density is used as starting value for algorithms that perform iterations in the density (or the volume). Note that the return value is a number density in units of inverse cubic angstrom.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">residual</span></code>: it returns a slice containing objects that implement the <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergy</span></code> trait (<em>trait objects</em>, see below). In other words: it returns the <em>different contributions</em> to the residual Helmholtz energy. This structure is motivated by the fact that equations of state can often be split into different, additive Helmholtz energy contributions.</p></li>
</ul>
<p>Implementing <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> comes down to defining one or more structs that all implement the <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergy</span></code> trait.</p>
<section id="the-helmholtzenergydual-and-helmholtzenergy-traits">
<h2>The <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> and <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergy</span></code> Traits<a class="headerlink" href="#the-helmholtzenergydual-and-helmholtzenergy-traits" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">residual</span></code> method returns a slice of trait objects, denoted by the <code class="docutils literal notranslate"><span class="pre">dyn</span></code> keyword.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="k">fn</span> <span class="nf">residual</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="p">[</span><span class="nb">Box</span><span class="o">&lt;</span><span class="k">dyn</span><span class="w"> </span><span class="n">HelmholtzEnergy</span><span class="o">&gt;</span><span class="p">];</span><span class="w"></span>
</pre></div>
</div>
<p>A <a class="reference external" href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait object</a> allows us to return a slice of <em>different structs</em> that share <em>common behavior</em>, i.e. all implement the same trait.
Discussion of trait objects is out of the scope of this documentation - for now it is sufficient to note that <a class="reference external" href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#object-safety-is-required-for-trait-objects">not all traits can be made into trait objects</a>.
In fact, a trait is not <em>object-safe</em> (i.e. cannot be made into a trait object) if it has generic type parameters.
This is a problem, since we want to be able to use generic dual numbers as type parameters for our equation of state.
The non-object-safe trait to do that is the <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> trait:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// This trait cannot be made into a trait object</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">D</span>: <span class="nc">DualNum</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">helmholtz_energy</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">StateHD</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">D</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Our solution is to create an object-safe <a class="reference external" href="https://doc.rust-lang.org/book/ch19-03-advanced-traits">supertrait</a>.html#using-supertraits-to-require-one-traits-functionality-within-another-trait) that wraps <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> with possible permutations of type parameters:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// automatically implemented for struct that implements `HelmholtzEnergyDual`</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">HelmholtzEnergy</span>:
    <span class="nc">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">Dual64</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">HyperDual64</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">Dual3_64</span><span class="o">&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">HyperDual</span><span class="o">&lt;</span><span class="n">Dual64</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">Dual3</span><span class="o">&lt;</span><span class="n">Dual64</span><span class="p">,</span><span class="w"> </span><span class="kt">f64</span><span class="o">&gt;&gt;</span><span class="w"></span>
<span class="w">    </span><span class="o">+</span><span class="w"> </span><span class="n">fmt</span>::<span class="n">Display</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Once we implement <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> for our structs, the <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergy</span></code> trait is automatically implemented and we can create and return trait objects.
This is a bit of an inconvenience but as long as we don’t need <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> with a new dual number it’s not an issue in practice.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">helmholtz_energy</span></code> method must return the <strong>reduced</strong> energy, i.e. <span class="math notranslate nohighlight">\(\frac{A^\text{res}}{k_B T}\)</span>.</p>
</section>
<section id="residual-helmholtz-energy">
<h2>Residual Helmholtz Energy<a class="headerlink" href="#residual-helmholtz-energy" title="Permalink to this headline">¶</a></h2>
<p>The residual Helmholtz energy is then computed as sum of all contributions:</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="sd">/// Evaluate the residual reduced Helmholtz energy $\beta A^\mathrm{res}$.</span>
<span class="sd">///</span>
<span class="sd">/// For simple equations of state (see e.g. `PengRobinson`) it might be</span>
<span class="sd">/// easier to overwrite this function instead of implementing `residual`.</span>
<span class="k">fn</span> <span class="nf">evaluate_residual</span><span class="o">&lt;</span><span class="n">D</span>: <span class="nc">DualNum</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">StateHD</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">D</span><span class="w"></span>
<span class="k">where</span><span class="w"></span>
<span class="w">    </span><span class="k">dyn</span><span class="w"> </span><span class="n">HelmholtzEnergy</span>: <span class="nc">HelmholtzEnergyDual</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="bp">self</span><span class="p">.</span><span class="n">residual</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">iter</span><span class="p">()</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="n">c</span><span class="o">|</span><span class="w"> </span><span class="n">c</span><span class="p">.</span><span class="n">helmholtz_energy</span><span class="p">(</span><span class="n">state</span><span class="p">))</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">sum</span><span class="p">()</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>As noted before, this structure is informed by equations of state with multiple contributions to the residual Helmholtz energy.
If we implement an equation of state with a single contribution, it might be more convenient to overwrite the <code class="docutils literal notranslate"><span class="pre">evaluate_residual</span></code> function.</p>
</section>
<section id="the-ideal-gas-contribution">
<h2>The Ideal Gas Contribution<a class="headerlink" href="#the-ideal-gas-contribution" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> trait has an <code class="docutils literal notranslate"><span class="pre">ideal_gas</span></code> method that returns a <code class="docutils literal notranslate"><span class="pre">IdealGasContribution</span></code> trait object.
If we don’t overwrite this method, it returns a default contribution in which the de Broglie wavelength is unity for each component.</p>
<p>This contribution is important if you are interested in non-residual properties, e.g. total heat capacities and total enthalpies.
Note that the default implementation yields the correct results for properties that do not include derivatives with respect to temperature because the de Broglie wavelength then cancels out.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: feos-core/src/equation_of_state.rs</span>

<span class="sd">/// A general equation of state.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EquationOfState</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// other methods omitted.</span>

<span class="w">    </span><span class="sd">/// Return the ideal gas contribution.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// Per default this function returns an ideal gas contribution</span>
<span class="w">    </span><span class="sd">/// in which the de Broglie wavelength is 1 for every component.</span>
<span class="w">    </span><span class="sd">/// Therefore, the correct ideal gas pressure is obtained even</span>
<span class="w">    </span><span class="sd">/// with no explicit ideal gas term. If a more detailed model is</span>
<span class="w">    </span><span class="sd">/// required (e.g. for the calculation of enthalpies) this function</span>
<span class="w">    </span><span class="sd">/// has to be overwritten.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">ideal_gas</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="kp">&amp;</span><span class="nc">dyn</span><span class="w"> </span><span class="n">IdealGasContribution</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">DefaultIdealGasContribution</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">IdealGasContribution</span></code> supertrait is assembled from <code class="docutils literal notranslate"><span class="pre">IdealGasContributionDual</span></code> (for an explanation why, see <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergy</span></code> trait), where we have to provide an implementation for the <code class="docutils literal notranslate"><span class="pre">de_broglie_wavelength</span></code> (actually <span class="math notranslate nohighlight">\(\ln \Lambda^3\)</span> with <span class="math notranslate nohighlight">\([\Lambda] = A\)</span>):</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: feos-core/src/equation_of_state.rs</span>

<span class="sd">/// Ideal gas Helmholtz energy contribution that can</span>
<span class="sd">/// be evaluated using generalized (hyper) dual numbers.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">IdealGasContributionDual</span><span class="o">&lt;</span><span class="n">D</span>: <span class="nc">DualNum</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="sd">/// The thermal de Broglie wavelength of each component in the form $\ln\left(\frac{\Lambda^3}{\AA^3}\right)$</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">de_broglie_wavelength</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">temperature</span>: <span class="nc">D</span><span class="p">,</span><span class="w"> </span><span class="n">components</span>: <span class="kt">usize</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">Array1</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="sd">/// Evaluate the ideal gas contribution for a given state.</span>
<span class="w">    </span><span class="sd">///</span>
<span class="w">    </span><span class="sd">/// In some cases it could be advantageous to overwrite this</span>
<span class="w">    </span><span class="sd">/// implementation instead of implementing the de Broglie</span>
<span class="w">    </span><span class="sd">/// wavelength.</span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">evaluate</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">StateHD</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">D</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kd">let</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="p">.</span><span class="n">de_broglie_wavelength</span><span class="p">(</span><span class="n">state</span><span class="p">.</span><span class="n">temperature</span><span class="p">,</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">moles</span><span class="p">.</span><span class="n">len</span><span class="p">());</span><span class="w"></span>
<span class="w">        </span><span class="p">((</span><span class="n">lambda</span><span class="w"></span>
<span class="w">            </span><span class="o">+</span><span class="w"> </span><span class="n">state</span><span class="p">.</span><span class="n">partial_density</span><span class="p">.</span><span class="n">mapv</span><span class="p">(</span><span class="o">|</span><span class="n">x</span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">re</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">D</span>::<span class="n">from</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                    </span><span class="n">x</span><span class="p">.</span><span class="n">ln</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1.0</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">            </span><span class="p">}))</span><span class="w"></span>
<span class="w">            </span><span class="o">*</span><span class="w"> </span><span class="o">&amp;</span><span class="n">state</span><span class="p">.</span><span class="n">moles</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">.</span><span class="n">sum</span><span class="p">()</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Accordingly, the Helmholtz energy is given by</p>
<div class="math notranslate nohighlight">
\[\frac{A^\text{ideal gas}}{RT} = \sum_i^{N_s} n_i (\ln [\rho_i \Lambda_i^3] - 1)\]</div>
<p>where <span class="math notranslate nohighlight">\(i\)</span> is the substance index and <span class="math notranslate nohighlight">\(N_s\)</span> denotes the number of substances in the mixture.</p>
</section>
<section id="additional-traits">
<h2>Additional Traits<a class="headerlink" href="#additional-traits" title="Permalink to this headline">¶</a></h2>
<section id="the-molarweight-trait">
<h3>The <code class="docutils literal notranslate"><span class="pre">MolarWeight</span></code> Trait<a class="headerlink" href="#the-molarweight-trait" title="Permalink to this headline">¶</a></h3>
<p>If an equation of state implements this trait, a <code class="docutils literal notranslate"><span class="pre">State</span></code> created with the equation of state additionally provides mass specific variants of all properties.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: feos-core/src/equation_of_state.rs</span>
<span class="sd">/// Molar weight of all components.</span>
<span class="sd">///</span>
<span class="sd">/// The trait is required to be able to calculate (mass)</span>
<span class="sd">/// specific properties.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">MolarWeight</span><span class="o">&lt;</span><span class="n">U</span>: <span class="nc">EOSUnit</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">molar_weight</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nc">QuantityArray1</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="the-entropyscaling-trait">
<h3>The <code class="docutils literal notranslate"><span class="pre">EntropyScaling</span></code> Trait<a class="headerlink" href="#the-entropyscaling-trait" title="Permalink to this headline">¶</a></h3>
<p>This trait provides methods to compute dynamic properties via <a class="reference external" href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.15.2545">entropy scaling</a>.
We have to implement a <em>reference</em> to produce the reduced property and a <em>correlation function</em> that models the behavior of the logarithmic reduced property as a function of the reduced residual entropy.</p>
<div class="highlight-rust notranslate"><div class="highlight"><pre><span></span><span class="c1">// file: feos-core/src/equation_of_state.rs</span>
<span class="sd">/// Reference values and residual entropy correlations for entropy scaling.</span>
<span class="k">pub</span><span class="w"> </span><span class="k">trait</span><span class="w"> </span><span class="n">EntropyScaling</span><span class="o">&lt;</span><span class="n">U</span>: <span class="nc">EOSUnit</span><span class="p">,</span><span class="w"> </span><span class="n">E</span>: <span class="nc">EquationOfState</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">viscosity_reference</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">State</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">QuantityScalar</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">EoSError</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">viscosity_correlation</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">s_res</span>: <span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">Array1</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">EoSError</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">diffusion_reference</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">State</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">QuantityScalar</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">EoSError</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">diffusion_correlation</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"> </span><span class="n">s_res</span>: <span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">Array1</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">EoSError</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">thermal_conductivity_reference</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">state</span>: <span class="kp">&amp;</span><span class="nc">State</span><span class="o">&lt;</span><span class="n">U</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="n">QuantityScalar</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">EoSError</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">thermal_conductivity_correlation</span><span class="p">(</span><span class="w"></span>
<span class="w">        </span><span class="o">&amp;</span><span class="bp">self</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">s_res</span>: <span class="kt">f64</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="n">x</span>: <span class="kp">&amp;</span><span class="nc">Array1</span><span class="o">&lt;</span><span class="kt">f64</span><span class="o">&gt;</span><span class="p">,</span><span class="w"></span>
<span class="w">    </span><span class="p">)</span><span class="w"> </span>-&gt; <span class="nb">Result</span><span class="o">&lt;</span><span class="kt">f64</span><span class="p">,</span><span class="w"> </span><span class="n">EoSError</span><span class="o">&gt;</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>To implement an equation of state that consists of multiple contributions to the residual Helmholtz energy, we:</p>
<ol class="arabic simple">
<li><p>Create a struct for our model parameters.</p></li>
<li><p>Create a struct for each contribution to the residual Helmholtz energy. Store the parameters in a reference counted pointer (e.g. <code class="docutils literal notranslate"><span class="pre">Rc</span></code>).</p></li>
<li><p>For each of these structs we implement the <code class="docutils literal notranslate"><span class="pre">HelmholtzEnergyDual</span></code> trait.</p></li>
<li><p>Create the struct that will be our equation of state. Store our model parameters (also in a <code class="docutils literal notranslate"><span class="pre">Rc</span></code>), and our contributions.</p></li>
<li><p>Then, implement <code class="docutils literal notranslate"><span class="pre">EquationOfState</span></code> (<code class="docutils literal notranslate"><span class="pre">components</span></code>, <code class="docutils literal notranslate"><span class="pre">get_subset</span></code>, <code class="docutils literal notranslate"><span class="pre">compute_max_density</span></code>, and <code class="docutils literal notranslate"><span class="pre">residual</span></code>) for this struct.</p></li>
</ol>
</section>
</section>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2021, Gernot Bauer, Philipp Rehner.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.3.1.<br/>
    </p>
  </div>
</footer>
  </body>
</html>